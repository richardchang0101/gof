原型模式：
    使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。
结构：
    Prototype(抽象原型类):他是声明克隆方法的接口，是所有具体原型类的公共父类，他可以是抽象类也可是接口，甚至还可以是具体实现类。
    ConcretePrototype(具体原型类)：他实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象
    Cliect(客户类)：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等创建一个原型对象，在通过调用该对象的克隆方法即可得到多个相同对象。由于客户类针对抽象原型类Prototype编程，
    因此用户可以根据需要选择具体的原型类，系统具有较好的可扩展性，增加或者更换具体原型类都很方便。
优点：
    创建新类较为复杂时，简化创建流程。
    扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类卸载配置文件中，增加或者减少产品类对原有系统没有影响
    原型模式提供了简化的创建结构，直接通过封装在原型类中的克隆方法实现，无需专门的工厂类创建产品。
    可以使用神克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，可辅助实现撤销操作。
缺点：
    克隆方法位于类内部， 需要做出改变时违背开闭原则。
    当存在多层嵌套时，为了实现深克隆，需要对每一层对象对应的类都实现深克隆。