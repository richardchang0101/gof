适配器模式：
    将一个类的接口转换成客户希望的赢一个接口，适配器模式让模式不兼容的类可以一起工作。
组成：
    Target 目标抽象类：目标抽象类定义客户所需的接口，可以是一个抽象类或者接口，也可以是具体类。java不支持多继承，只能是接口。
    Adapter 适配器类：他可以调用另一个接口，作为一个转换器，对adaptee和Target进行适配。适配器Adapter是适配器模式的核心，在类适配器中，他通过关联一个Adaptee对象使两者产生关系。
    Adaptee适配者类：适配者即被适配的对象，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含客户希望使用的业务方法，在某些情况下甚至没有适配者类的源代码
优点：目标又适配器解耦，通过引入适配器类来重用现有的适配者类，无需修改原有结构。
    增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于呵护短类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用
    灵活性和扩展性都非常好，可以很方便的更换适配器，也可以在不修改原有的代码的基础上增加新的适配器类，完全符合开闭原则。
    一个对象适配器可以把多个不同的适配者适配到同一个目标
    可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据里氏代还原则，适配者的子类也可以通过该适配器进行适配
缺点：java等不支持多继承的语言，一次只能适配一个适配者类，不能同时适配多个适配者。
    适配者类不能为最终类，也就是java中用final修饰的类
    在java语言中，类适配器模式中的目标抽象类只能为接口，不能为类，具有一定局限性。

使用环境：
    系统需要使用原有的类，而这个类的接口不符合系统的需要，甚至没有这类的源代码。
    想创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类（包括可能将来引进的类）一起工作