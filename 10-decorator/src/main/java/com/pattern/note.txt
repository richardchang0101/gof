装饰模式：
    动态的给一个对象增加一些额外职责。就扩展工能而言，装饰模式提供了一种比使用子类更加灵活的替代方案
抽象构件Component：他是具体构件和抽象装饰类的共同父类，声明在具体构建中实现的业务方法，他的引入可以是客户端以一致的方式处理违背装饰的对下稿以及装饰之后的对象，实现客户端的透明操作
具体构件ConcreteComponent：他可以抽象构建类的子类，用于定义具体的构建对象，实现了在抽象构件中声明的具体方法，装饰类可以给他增加额外的职责
抽象装饰类Deorator：他也可以抽在那个构建类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。他是维护一个指向抽象构建对象的引用，通过该引用可以调用装饰之前构建对象的方法，并通过子类扩展该方法，已达到装饰的目的
具体装饰类ConcreteDecorator：他是装饰抽象类的子类，负责向构建添加新的职责。每个具体装饰类都定义了一些新的行为，他可以调用在抽象张石磊定义的方法，并可以增加新的方法用于扩充对象的行为

优点：
    对于扩展一个对象的功能，装饰模式比集成模式更加灵活，不会导致类的个数几句增加。
    可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行是选择不同的具体装饰类，从而实现不同的行为
    可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合可以创造出很多不同行为的组合，得到功能更加强大的对象
    具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构建类和具体装饰类，原有代码无需改变，符合开闭原则
缺点：
    在使用装饰模式进行系统设计是将产生很多小对象，这些对象的区别在于他们之间相互连接的方式有多不同，而不是他们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程度上影响程序的性能
    装饰模式提供了一种比继承更加灵活。激动的解决方案，但同时也以为者比继承更加易于出错，排错也更加困难，对于多次装饰的对象，在调试是寻找错误可能需要逐级排查，较为繁琐
