观察者模式：  发布订阅模式
    定义对象之间的一种一对多的依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知被自动更新
组成
    目标Subject：目标又称主题，他是被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，他提供一些列方法来增加和删除观察者对象，同时它定义了通知方法notify
        目标类可以是接口，也可以是抽象类或者具体类
    具体目标ConcreteSubject：具体目标是目标类的子类，他通过包含有经常发生改变的数据，当它的状态发生改变时将向它的哥哥观察者发送通知；同时他还实现了在目标类中定义抽象业务逻辑方法（如果有）。如果无需扩展目标类，则具体目标类可以省略
    观察者Observer：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update，因此又称为抽象观察者
    具体观察者ConcreteObserver：在具体观察者中维护了一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者中定义的update方法。通常在实现时可以调用具体目标类的attach方法将自己添加到目标类的集合中或通过detach方法将自己从目标类集合中删除
优点：
    可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。
    在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密的耦合在一起，因此他们可以属于不同的抽象化层次
    支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计复杂难度
    符合开闭原则，增加新的具体观察者无需修改原有代码，再具体观察者与管着目标之间不存在关联关系的情况下增加新的观察目标也很方便
缺点：
    如果一个观察目标对象有很多直接和间接观察者，将所有观察者都通知会花很多时间。
    如果观察者和观察目标之间存在循环依赖，观察目标会触发他们之间进行循环调用，可能导致系统崩溃
    观察者模式没有相应的机制让观察者知道所观察目标的对象是怎么发生变化的，只知道目标对象发生了变化