策略模式：
    定义一系列算法将每一个算法封装起来，并让他们可以相互转换。策略模式让算法可以独立于使用它的客户而变化
组成
    环境类Context：环境类是使用算法的角色，在解决某个问题（即实现某个功能）时可以采取多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略
    抽象策略类Strategy：抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类，他可以是抽象类或者具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法
    具体策略类ConcreteStrategy：具体策略类实现了抽象策略类中声明的算法，在运行时具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务功能。
优点：
    策略模式提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或者行为，也可以灵活的增加新的算法或行为。
    策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或者行为族，恰当的使用继承可以吧公共的代码移到抽象策略类中，从而避免重复代码
    策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法环境可能会多一些子类，每一个子类提供一种不同算法，但是这样一来算法使用和算法本身混在一起了，不符合单一职责原则，决定使用哪一种算法的逻辑和该算法本身混在一起，从而不可能独立演化，而且使用继承无法实现算法或行为在程序运行的动态切换
    使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将他们全部硬编码在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始落后
    策略模式提供了之中算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便服用这些策略类
缺点：
    客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当算法。换言之，策略模式只使用与客户端知道所有算法的情况
    策略模式将造成系统产生很多策略类，任何细小变化都将导致系统要增加新的具体策略类
    无法同时在客户端使用多个策略类，也就是说在使用策略模式时客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用其他策略类完成剩余功能的情况。